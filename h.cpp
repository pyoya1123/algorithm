#include <iostream>
using namespace std;
#include <cmath>

long long dp[2002][2002];

int tc, n,m;

int main() {
    for(int i=1;i<=2000;i++) dp[i][1] = i;
    for(int i=2;i<=10;i++){
        for(int j=(int)pow(2,i-1);j<=2000;j++){
            dp[j][i] = dp[j-1][i] + dp[j/2][i-1];
        }
    }
    cin >> tc;
    while(tc--){
        cin >> n >> m;
        cout << dp[m][n] << "\n";
    }
}


/*
my sol>
4 8 -> (1,2,4,8)
4 9 -> (1,2,4,8), [1,2,4,9]
4 10 -> (1,2,4,8), (1,2,4,9), [1,2,4,10], [1,2,5,10]
4 11 -> (1,2,4,8), (1,2,4,9), (1,2,4,10), (1,2,5,10), [1,2,4,11], [1,2,5,11]
4 12 -> (1,2,4,8), (1,2,4,9), (1,2,4,10), (1,2,5,10), (1,2,4,11), (1,2,5,11)
        [1,2,4,12], [1,2,5,12], [1,2,6,12], [1,3,6,12]

위에서 4 9 에서 4 10으로 바뀌는 과정을 보면,
[1,2,4,10], [1,2,5,10] 이만큼이 추가가 되었다.
여기서 [1,2,4], [1,2,5]는 dp[5][2]를 의미함.

위에서 4 11 에서 4 12로 바뀌는 과정을 보면,
[1,2,4,12], [1,2,5,12], [1,2,6,12], [1,3,6,12] 이만큼이 추가가 되었다.
여기서 [1,2,4], [1,2,5], [1,2,6], [1,3,6]은 dp[6][3]을 의미함.

규칙성이 보임.
점화식 -> dp[i][j] = dp[i-1][j] + dp[i/2][j-1]
*/